library(shiny)
library(bslib)
library(ggplot2)
library(thematic)
library(ggtext)
library(glue)

# Default is use caching
if (getOption("cache", TRUE)) {
  bindCache <- shiny::bindCache
  print("Enabling caching")
} else {
  bindCache <- function(x, ...) x
  print("Disabling caching")
}

source('helpers.R')

# Builds theme object to be supplied to ui
my_theme <- bs_theme(bootswatch = "cerulean",
                     base_font = font_google("Righteous"),
                     "font-size-base" = "1.1rem")

# Let thematic know to use the font from bs_lib
thematic_on(font = "auto")

# We have an already build station to city df we are using for lookups
station_to_city <- read_rds(here("data/station_to_city.rds"))

# Some cities have multiple stations but we only want users to see unique cities
unique_cities <- unique(station_to_city$city)
# We start with a random city in the back button and have a random city jump button
get_random_city <- function(){ sample(unique_cities, 1) }

ui <- fluidPage(
  theme = my_theme,
  includeCSS("styles.css"),
  div(id = "header",
      titlePanel("Explore your weather"),
      labeled_input('city-selector', "Search for a city",
                    selectizeInput('city', label = NULL,
                                   choices = c("", unique_cities),
                                   multiple = FALSE)),
      labeled_input("prev_city_btn", "Return to previous city",
                    actionButton('prev_city', textOutput('prev_city_label'))),
      labeled_input("rnd_city_btn", "Try a random city",
                    actionButton('rnd_city', icon('dice')))),
  plotOutput("tempPlot", height = 600),
  plotOutput("prcpPlot"),
  div(id = "contributing_stations",
      span("Stations contributing data"),
      span("Click on station to go to its dataset."),
      uiOutput('station_info') ),
  div(id = "data_info",
      icon("database"), "Data sourced from",
      a(href = "https://www.ncdc.noaa.gov/data-access/land-based-station-data/land-based-datasets/climate-normals", "NOAA Climate Normals"),
      "generated by taking average temperatures from weather stations over the years 1982-2010.",
      "For cities with multiple weather stations the average across all reporting stations is used.")
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {
  # If the URL contains a city on load, use that city instead of the default of ann arbor
  bookmarked_city <- isolate(getUrlHash()) %>% str_replace_all("-", " ") %>% str_remove("#")
  current_city <- reactiveVal( if(bookmarked_city %in% unique_cities) bookmarked_city else "Ann Arbor, MI")
  updateSelectizeInput(inputId = "city", selected = isolate(current_city()))

  # A book-keeping reactive so we can have a previous city button
  previous_city <- reactiveVal(NULL)

  observe({
    req(input$city)
    # Set the previous city to the non-updated current city. If app is just
    # starting we want to populate the previous city button with a random city,
    # not the current city
    selected_city <- isolate(current_city())
    just_starting <- selected_city == input$city
    previous_city(if(just_starting) get_random_city() else selected_city)

    # Current city now can be updated to the newly selected city
    current_city(input$city)

    # Update the query string so the app will know what to do.
    updateQueryString(paste0("#",str_replace_all(current_city(), "\\s", "-")), mode = "push")
  })

  observe({
    updateSelectizeInput(inputId = "city", selected = isolate(previous_city()))
  }) %>% bindEvent(input$prev_city)

  observe({
    updateSelectizeInput(inputId = "city", selected = get_random_city())
  }) %>% bindEvent(input$rnd_city)

  city_data <- reactive({
    req(input$city, cancelOutput = TRUE)

    withProgress(message = 'Fetching data from NOAA', {
      incProgress(0, detail = "Gathering all stations within city")
      stations <- filter(station_to_city, city == input$city)

      # Not every station has temperature data. This loops through all stations in
      # a city and tries to find one with temperature data. If there are a lot of
      # stations, this can take a while
      incProgress(1/4, detail = "Downloading data from all found stations")
      stations <- stations %>%
        mutate(url = build_station_url(station),
               data = safe_map(url, readr::read_file))

      # If we have multiple stations with data we just collapse it to the mean
      collapse_stations <- . %>%
        reduce(bind_rows, .init = tibble(date = Date())) %>%
        group_by(date) %>%
        summarise_all(mean)

      incProgress(2/4, detail = "Extracting temperature data")
      stations$temp_res <- safe_map(stations$data, get_temp_data)
      temperature <- collapse_stations(stations$temp_res)

      incProgress(3/4, detail = "Extracting precipitation data")
      stations$prcp_res <- safe_map(stations$data, get_prcp_data)
      precipitation <- collapse_stations(stations$prcp_res)

      incProgress(1, detail = "Packaging data for app")
      list(temperature = temperature,
           precipitation = precipitation,
           station_info = stations %>%
             mutate(had_temp = !map_lgl(temp_res, is.null),
                    had_prcp = !map_lgl(prcp_res, is.null)) %>%
             select(-data, -temp_res, -prcp_res))
    })
  }) %>%
    # Our results will always be the same for a given city, so cache on that key
    bindCache(input$city)

  output$station_info <- renderUI({
    temp_icon <- as.character(icon('thermometer-half'))
    prcp_icon <- as.character(icon('cloud-rain'))
    city_data()$station_info %>%
      glue_data("<div class='station_bubble'> <a href={url} target='_blank'>",
                "{station} {ifelse(had_temp, temp_icon, '')} {ifelse(had_prcp, prcp_icon, '')}",
                "</a></div>") %>%
      HTML()
  })

  output$prev_city_label <- renderText({ previous_city() })

  output$tempPlot <- renderPlot({
    validate(
      need(nrow(city_data()$temperature) != 0,
           glue("Sorry, no temperature data is available for {input$city}, try a nearby city."))
    )

    withProgress(message = 'Building temperature plot', {
      incProgress(0/2, detail = "Finding hottest and coldest days")

      extremes <- bind_rows(
        arrange(city_data()$temperature, -max, -avg, -min)[1,] %>%
          mutate(label = glue("Hottest day: {format(date, '%B %d')}<br>",
                              "Avg max temp = {format(max, digits = 3)}&#176;")),
        arrange(city_data()$temperature, min, avg, max)[1,] %>%
          mutate(label = glue("Coldest day: {format(date, '%B %d')}<br>",
                              "Avg min temp = {format(min, digits = 3)}&#176;"))
      )

      context_points <- tibble(
        label = c("107&#176;: hottest day in Pheonix, AZ", "-14.9&#176;: coldest day in Fairbanks, AK"),
        temp = c(107, -14.9)
      )

      incProgress(1/2, detail = "Rendering plot")

      ggplot(city_data()$temperature, aes(x = date, y = avg)) +
        geom_richtext(data = context_points,
                      aes(x = mdy("01-01-2000"), label = label, y = temp),
                      hjust = 0, vjust = c(0,1), nudge_y = c(1,-1), nudge_x = 2,
                      label.color = NA, fill = NA,
                      label.padding = grid::unit(rep(0, 4), "pt")) +
        geom_hline(data = context_points, aes(yintercept = temp)) +
        geom_ribbon(aes(ymin = min, ymax = max),
                    fill = "steelblue",
                    alpha = 0.25) +
        geom_line(color = "white") +
        geom_point(data = extremes) +
        ggtext::geom_richtext(data = extremes,
                              aes(label = label, hjust = ifelse(month(date) < 6, 0, 1)),
                              nudge_y = -1,
                              label.color = NA,
                              # Gives us a transparent background so text pops better
                              fill = after_scale(alpha("white", .5)),
                              vjust = 1 ) +
        labs(y = "temperature (&#176; F)",
             x = "",
             title = glue("{input$city} temperature over year")) +
        monthly_date_axis +
        scale_y_continuous(breaks = seq(from = -10, to = 100, by = 10)) +
        theme(text = element_text(size = 18),
              axis.text.x = element_text(hjust = 0),
              panel.grid.major = element_line(color = "grey70", size = 0.2),
              panel.grid.minor = element_line(color = "grey85", size = 0.2),
              axis.title.y = element_markdown(size = 18))
    })
  }) %>%
    bindCache(input$city, sizePolicy = sizeGrowthRatio(width = 400, height = 600))

  output$prcpPlot <- renderPlot({

    validate(
      need(nrow(city_data()$precipitation) != 0, # is NULL when no data available
           glue("Sorry, no precipitation data is available for {input$city}, try a nearby city."))
    )

    context_point <- tibble(
      label = c("9.47\": wettest month in Miami, FL"),
      avg_precipitation = c(11.48)
    )

    withProgress(message = 'Building precipitation plot', {

      incProgress(1/2, detail = "Rendering plot")

      city_data()$precipitation %>%
        ggplot(aes(x = date, y = avg_precipitation)) +
        geom_richtext(data = context_point,
                      aes(x = mdy("01-01-2000"), label = label, y = avg_precipitation),
                      hjust = 0, vjust = 0, nudge_y = 0.05, nudge_x = 2,
                      label.color = NA, fill = NA,
                      label.padding = grid::unit(rep(0, 4), "pt")) +
        geom_hline(data = context_point, aes(yintercept = avg_precipitation)) +
        geom_rect(aes(xmin = date, xmax = date + months(1), ymin = 0, ymax = avg_precipitation),
                  fill = "steelblue",
                  color = "white") +
        geom_text(aes(label = ifelse(avg_precipitation == 0, "> 0", format(avg_precipitation, digits = 3)), x = date + days(15)),
                  nudge_y = 0.05,
                  hjust = 0.5,
                  color = "black",
                  size = 5,
                  vjust = 0) +
        monthly_date_axis +
        scale_y_continuous(breaks = seq(from = 0, to = 10, by = 2),
                           expand = expansion(mult = c(0, 0.05))) +
        labs(y = "inches of precipitation",
             x = "",
             title = glue("{input$city} precipitation over year")) +
        theme(text = element_text(size = 18),
              axis.text.x = element_text(hjust = 0),
              panel.grid.major = element_line(color = "grey70", size = 0.2),
              panel.grid.minor = element_line(color = "grey85", size = 0.2),
              axis.title.y = element_markdown(size = 18))
    })
  }) %>%
    bindCache(input$city)
}

# Run the application
shinyApp(ui = ui, server = server)
# %>% run_with_themer()
