library(shiny)
library(bslib)
library(ggplot2)
library(thematic)
library(ggtext)
library(glue)

# Default is use caching
if (getOption("cache", TRUE)) {
  bindCache <- shiny::bindCache
  print("Enabling caching")
} else {
  bindCache <- function(x, ...) x
  print("Disabling caching")
}

source('helpers.R')

# Builds theme object to be supplied to ui
my_theme <- bs_theme(
  bootswatch = "cerulean",
  base_font = font_google("Righteous"),
  "font-size-base" = "1.1rem"
)
# Let thematic know to use the font from bs_lib
thematic_on(font = "auto")

# We have an already build station to city df we are using for lookups
station_to_city <- read_rds(here("data/station_to_city.rds"))

# Some cities have multiple stations but we only want users to see unique cities
unique_cities <- unique(station_to_city$city)
# We start with a random city in the back button and have a random city jump button
get_random_city <- function(){ sample(unique_cities, 1) }

ui <- fluidPage(
  theme = my_theme,
  tags$head(
    # Some css that makes everything above plot center aligned and keeps buttons sized reasonably
    tags$style(HTML("
        #header {
          display: grid;
          justify-items: center;
          grid-template-columns: repeat(3, 1fr);
          grid-template-rows: repeat(2, 1fr);
          align-items: flex-start;
        }

        #header > h2   { grid-area: 1 / 1 / 2 / 4; }
        #city-selector { grid-area: 2 / 2 / 3 / 3; }
        #prev_city_btn { grid-area: 2 / 1 / 3 / 2; }
        #rnd_city_btn  { grid-area: 2 / 3 / 3 / 4; }

        button { width: 200px; }
        button > div {
          text-overflow: ellipsis;
          overflow: hidden;
          white-space: nowrap;
        }
      "))),
  div(id = "header",
      titlePanel("Explore your weather"),
      labeled_input('city-selector',
                    "Search for a city",
                    selectizeInput('city',
                                   label = NULL,
                                   choices = unique_cities,
                                   selected = "Ann Arbor, MI",
                                   multiple = FALSE)),
      labeled_input("prev_city_btn",
                    "Return to previous city",
                    actionButton('prev_city', textOutput('prev_city_label'))),
      labeled_input("rnd_city_btn",
                    "Try a random city",
                    actionButton('rnd_city', icon('dice')))
  ),
  plotOutput("tempPlot", height = 600),
  plotOutput("prcpPlot"),
  div(icon("database"), "Data sourced from",
      a(href = "https://www.ncdc.noaa.gov/data-access/land-based-station-data/land-based-datasets/climate-normals", "NOAA Climate Normals"),
      "generated by taking average temperatures from weather stations over the years 1982-2010.",
      "For cities with multiple weather stations the average across all reporting stations is used.",
      style = "font-size: small;")
)

# Define server logic required to draw a histogram
server <- function(input, output, session) {

  city_data <- reactive({
    req(input$city, cancelOutput = TRUE)

    withProgress(message = 'Fetching data from NOAA', {
      incProgress(0, detail = "Gathering all stations within city")
      stations <- filter(station_to_city, city == input$city)

      # This is long but doesnt change
      station_url_prefix <- "https://www1.ncdc.noaa.gov/pub/data/normals/1981-2010/products/auxiliary/station"

      # Not every station has temperature data. This loops through all stations in
      # a city and tries to find one with temperature data. If there are a lot of
      # stations, this can take a while
      incProgress(1/4, detail = "Downloading data from all found stations")
      stations$data <- safe_map(stations$station, ~readr::read_file(glue("{station_url_prefix}/{.x}.normals.txt")))

      # If we have multiple stations with data we just collapse it to the mean
      collapse_stations <- . %>%
        reduce(bind_rows, .init = tibble(date = Date())) %>%
        group_by(date) %>%
        summarise_all(mean)

      incProgress(2/4, detail = "Extracting temperature data")
      stations$temp_res <- safe_map(stations$data, get_temp_data)
      temperature <- collapse_stations(stations$temp_res)

      incProgress(3/4, detail = "Extracting precipitation data")
      stations$prcp_res <- safe_map(stations$data, get_prcp_data)
      precipitation <- collapse_stations(stations$prcp_res)

      incProgress(1, detail = "Packaging data for app")
      list(temperature = temperature, precipitation = precipitation)
    })
  }) %>%
    # Our results will always be the same for a given city, so cache on that key
    bindCache(input$city)

  # These hold book keeping stuff so we can have a back button
  # Start previous city button at a random city by setting the current city as
  # random The observe below then moves that into the previous city value
  current_city <- reactiveVal(get_random_city())
  previous_city <- reactiveVal(NULL)

  observe({
    req(input$city)
    # Set the previous city to the non-updated current city.
    # We need an isolate() here to avoid causing this call
    # to trigger the reactive() update in a loop
    previous_city(isolate(current_city()))
    # Current city now can be updated to the newly selected city
    current_city(input$city)
  })

  output$prev_city_label <- renderText({ previous_city() })

  observe({
    updateSelectizeInput(
      session = session,
      inputId = "city",
      selected = isolate(previous_city())
    )
  }) %>% bindEvent(input$prev_city)

  observe({
    updateSelectizeInput(
      session = session,
      inputId = "city",
      selected = get_random_city()
    )
  }) %>% bindEvent(input$rnd_city)

  output$tempPlot <- renderPlot({
    validate(
      need(nrow(city_data()$temperature) != 0,
           glue("Sorry, no temperature data is available for {input$city}, try a nearby city."))
    )

    withProgress(message = 'Building temperature plot', {
      incProgress(0/2, detail = "Finding hottest and coldest days")

      extremes <- bind_rows(
        arrange(city_data()$temperature, -max, -avg, -min)[1,] %>%
          mutate(label = glue("Hottest day: {format(date, '%B %d')}<br>",
                              "Avg max temp = {format(max, digits = 3)}&#176;")),
        arrange(city_data()$temperature, min, avg, max)[1,] %>%
          mutate(label = glue("Coldest day: {format(date, '%B %d')}<br>",
                              "Avg min temp = {format(min, digits = 3)}&#176;"))
      )

      context_points <- tibble(
        label = c("107&#176;: hottest day in Pheonix, AZ", "-14.9&#176;: coldest day in Fairbanks, AK"),
        temp = c(107, -14.9)
      )

      incProgress(1/2, detail = "Rendering plot")

      ggplot(city_data()$temperature, aes(x = date, y = avg)) +
        geom_richtext(data = context_points,
                      aes(x = mdy("01-01-2000"), label = label, y = temp),
                      hjust = 0, vjust = c(0,1), nudge_y = c(1,-1), nudge_x = 2,
                      label.color = NA, fill = NA,
                      label.padding = grid::unit(rep(0, 4), "pt")) +
        geom_hline(data = context_points, aes(yintercept = temp)) +
        geom_ribbon(aes(ymin = min, ymax = max),
                    fill = "steelblue",
                    alpha = 0.25) +
        geom_line(color = "white") +
        geom_point(data = extremes) +
        ggtext::geom_richtext(data = extremes,
                              aes(label = label, hjust = ifelse(month(date) < 6, 0, 1)),
                              nudge_y = -1,
                              label.color = NA,
                              # Gives us a transparent background so text pops better
                              fill = after_scale(alpha("white", .5)),
                              vjust = 1 ) +
        labs(y = "temperature (&#176; F)",
             x = "",
             title = glue("{input$city} temperature over year")) +
        monthly_date_axis +
        scale_y_continuous(breaks = seq(from = -10, to = 100, by = 10)) +
        theme(text = element_text(size = 18),
              axis.text.x = element_text(hjust = 0),
              panel.grid.major = element_line(color = "grey70", size = 0.2),
              panel.grid.minor = element_line(color = "grey85", size = 0.2),
              axis.title.y = element_markdown(size = 18))
    })
  }) %>%
    bindCache(input$city, sizePolicy = sizeGrowthRatio(width = 400, height = 600))

  output$prcpPlot <- renderPlot({

    validate(
      need(nrow(city_data()$precipitation) != 0, # is NULL when no data available
           glue("Sorry, no precipitation data is available for {input$city}, try a nearby city."))
    )

    context_point <- tibble(
      label = c("9.47\": wettest month in Miami, FL"),
      avg_precipitation = c(11.48)
    )

    withProgress(message = 'Building precipitation plot', {

      incProgress(1/2, detail = "Rendering plot")

      city_data()$precipitation %>%
        ggplot(aes(x = date, y = avg_precipitation)) +
        geom_richtext(data = context_point,
                      aes(x = mdy("01-01-2000"), label = label, y = avg_precipitation),
                      hjust = 0, vjust = 0, nudge_y = 0.05, nudge_x = 2,
                      label.color = NA, fill = NA,
                      label.padding = grid::unit(rep(0, 4), "pt")) +
        geom_hline(data = context_point, aes(yintercept = avg_precipitation)) +
        geom_rect(aes(xmin = date, xmax = date + months(1), ymin = 0, ymax = avg_precipitation),
                  fill = "steelblue",
                  color = "white") +
        geom_text(aes(label = ifelse(avg_precipitation == 0, "> 0", format(avg_precipitation, digits = 3)), x = date + days(15)),
                  nudge_y = 0.05,
                  hjust = 0.5,
                  color = "black",
                  size = 5,
                  vjust = 0) +
        monthly_date_axis +
        scale_y_continuous(breaks = seq(from = 0, to = 10, by = 2),
                           expand = expansion(mult = c(0, 0.05))) +
        labs(y = "inches of precipitation",
             x = "",
             title = glue("{input$city} precipitation over year")) +
        theme(text = element_text(size = 18),
              axis.text.x = element_text(hjust = 0),
              panel.grid.major = element_line(color = "grey70", size = 0.2),
              panel.grid.minor = element_line(color = "grey85", size = 0.2),
              axis.title.y = element_markdown(size = 18))
    })
  }) %>%
    bindCache(input$city)
}

# Run the application
shinyApp(ui = ui, server = server)
# %>% run_with_themer()
